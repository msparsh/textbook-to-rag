Python is not optimal for programs that have high reliability constraints (because of its weak static semantic checking) or that are built and maintained by many people or over a long period of time (again because of the weak static semantic checking). Python does have several advantages over many other languages. It is a relatively simple language that is easy to learn. Because Python is designed to be interpreted, it can provide the kind of runtime feedback that is especially helpful to novice programmers. A large and growing number of freely available libraries interface to Python and provide useful extended functionality. We use several of these libraries in this book. We are ready to introduce some of the basic elements of Python. These are common to almost all programming languages in concept, though not in detail. This book is not just an introduction to Python. It uses Python as a vehicle to present concepts related to computational problem solving and thinking. The language is presented in dribs and drabs, as needed for this ulterior purpose. Python features that we don't need for that purpose are not presented at all. We feel comfortable about not covering every detail because excellent online resources describe every aspect of the language. We suggest that you use these free online resources as needed. Python is a living language. Since its introduction by Guido von Rossum in 1990, it has undergone many changes. For the first decade of its life, Python was a little known and little used language. That changed with the arrival of Python 2.0 in 2000.

In addition to incorporating important improvements to the language itself, it marked a shift in the evolutionary path of the language. Many groups began developing libraries that interfaced seamlessly with Python, and continuing support and development of the Python ecosystem became a community-based activity. Python 3.0 was released at the end of 2008. This version of Python cleaned up many of the inconsistencies in the design of Python 2. However, Python 3 is not backward compatible. This means that most programs and libraries written for earlier versions of Python cannot be run using implementations of Python 3. By now, all of the important public domain Python libraries have been ported to Python 3. Today, there is no reason to use Python 2. 2.1 Installing Python and Python IDEs Once upon time, programmers used general-purpose text editors to enter their programs. Today, most programmers prefer to use a text editor that is part of an integrated development environment (IDE). The first Python IDE, IDLE,9 came as part of the standard Python installation package. As Python has grown in popularity, other IDEs have sprung up. These newer IDEs often incorporate some of the more popular Python libraries and provide facilities not provided by IDLE. Anaconda and Canopy are among the more popular of these IDEs. The code appearing in this book was created and tested using Anaconda. IDEs are applications, just like any other application on your computer. Start one the same way you would start any other application, e.g., by double-clicking on an icon.

We even demonstrate that fact in Section 18.4. 15 “What's in a name? That which we call a rose by any other name would smell as sweet.” 16 Unlike many programming languages, Python has no type corresponding to a character. Instead, it uses strings of length 1. 17 These modifiers are the same modifiers used in the .format method associated with strings. 18 In 2016, over 85% of the pages on the web were encoded using UTF-8. 19 It is also possible to hand-simulate a program using pen and paper, or even a text editor. 20 Pride and Prejudice, Jane Austen. 21 PEP is an acronym standing for “Python Enhancement Proposal.” PEP 8 was written in 2001 by Guido van Rossum, Barry Warsaw, and Nick Coghlan. 3 SOME SIMPLE NUMERICAL PROGRAMS Now that we have covered some basic Python constructs, it is time to start thinking about how we can combine those constructs to write simple programs.

About the same time, the programming languages SmallTalk (at Xerox PARC) and CLU (at MIT) provided linguistic support for the ideas. But it wasn't until the arrival of C++ and Java that object-oriented programming really took off in practice. We have been implicitly relying on object-oriented programming throughout most of this book. Back in Section 2.2.1 we said “Objects are the core things that Python programs manipulate. Every object has a type that defines the kinds of things that programs can do with that object.” Since Chapter 2, we have relied upon built-in types such as float and str and the methods associated with those types.

And others are challenging enough to be useful as homework assignments. Chapters 1-13 contain the kind of material typically included in an introductory computer science course, but the presentation is not conventional. We braid together four strands of material: The basics of programming, The Python 3 programming language, Computational problem solving techniques, and Computational complexity. We cover most of Python's features, but the emphasis is on what one can do with a programming language, not on the language itself. For example, by the end of Chapter 3, the book has covered only a small fraction of Python, but it has already introduced the notions of exhaustive enumeration, guess-and-check algorithms, bisection search, and efficient approximation algorithms. We introduce features of Python throughout the book. Similarly, we introduce aspects of programming methods throughout the book. The idea is to help readers learn Python and how to be a good programmer in the context of using computation to solve interesting problems. These chapters have been revised to proceed more gently and include more excercises than the corresponding chapters in the second edition of this book. Chapter 13 contains an introduction to plotting in Python. This topic is often not covered in introductory courses, but we believe that learning to produce visualizations of information is an important skill that should be included in an introductory computer science course. This chapter includes material not covered in the second edition. Chapters 14-26 are about using computation to help understand the real world.

The primitive constructs in Python include literals (e.g., the number 3.2 and the string ‘abc’) and infix operators (e.g., + and /). The syntax of a language defines which strings of characters and symbols are well formed. For example, in English the string “Cat dog boy.” is not a syntactically valid sentence, because English syntax does not accept sentences of the form <noun> <noun> <noun>. In Python, the sequence of primitives 3.2 + 3.2 is syntactically well formed, but the sequence 3.2 3.2 is not. The static semantics defines which syntactically valid strings have a meaning. Consider, for example, the strings “He run quickly” and “I runs quickly.” Each has the form <pronoun> <regular verb> <adverb>, which is a syntactically acceptable sequence. Nevertheless, neither is valid English, because of the rather peculiar rule that for a regular verb when the subject of a sentence is first or second person, the verb does not end with an “s,” but when the subject is third person singular, it does.

This standard included 128 characters, plenty for representing the usual set of characters appearing in English-language text—but not enough to cover the characters and accents appearing in all the world's languages. The Unicode standard is a character coding system designed to support the digital processing and display of the written texts of all languages. The standard contains more than 120,000 characters— covering 129 modern and historic scripts and multiple symbol sets. The Unicode standard can be implemented using different internal character encodings. You can tell Python which encoding to use by inserting a comment of the form # -*- coding: encoding name -*- as the first or second line of your program. For example, # -*- coding: utf-8 -*- instructs Python to use UTF-8, the most frequently used character encoding for webpages.18 If you don't have such a comment in your program, most Python implementations will default to UTF-8. When using UTF-8, you can, text editor permitting, directly enter code like print('Mluvíš anglicky?') print('Ɛा आप अंŤेज़ी बोलते हœ?') which will print Mluvíš anglicky? Ɛा आप अंŤेज़ी बोलते हœ? You might be wondering how I managed to type the string 'Ɛा आप अंŤेज़ी बोलते हœ?'. I didn't. Because most of the web uses UTF-8, I was able to cut the string from a webpage and paste it directly into my program. There are ways to directly enter Unicode characters from a keyboard, but unless you have a special keyboard, they are all rather cumbersome. 2.5 While Loops Near the end of Section 2.3, we mentioned that most computational tasks cannot be accomplished using branching programs.

All of the Python IDEs provide A text editor with syntax highlighting, auto completion, and smart indentation, A shell with syntax highlighting, and An integrated debugger, which you can safely ignore for now. This would be a good time to install Anaconda (or some other IDE) on your computer, so that you can run the examples in the book, and, more importantly, attempt the programming finger exercises. To install Anaconda, go to https://www.anaconda.com/distribution/ and follow the instructions. Once the installation is complete, start the application Anaconda- Navigator. A window containing a collection of Python tools will appear. The window will look something like Figure 2-1.10 For now, the only tool we will use is Spyder. When you launch Spyder (by clicking on its Launch button, of all things), a window similar to Figure 2-2 will open. Figure 2-1 Anaconda startup window Figure 2-2 Spyder window The pane on the lower right of Figure 2-2 is an IPython console running an interactive Python shell.

You can type and execute Python commands in this window. The pane on the upper right is a help window. It is often convenient to close that window (by clicking on the x), so that more real estate is available for the IPython console. The pane on the left is an edit window into which you can type programs that can be saved and run. The toolbar at the top of the window makes it easy to perform various tasks such as opening files and printing programs.11 Documentation for Spyder can be found at https://www.spyder-ide.org/. 2.2 The Basic Elements of Python A Python program, sometimes called a script, is a sequence of definitions and commands. The Python interpreter in the shell evaluates the definitions and executes the commands. We recommend that you start a Python shell (e.g., by starting Spyder) now, and use it to try the examples contained in the rest of this chapter. And, for that matter, in the rest of the book. A command, often called a statement, instructs the interpreter to do something. For example, the statement print('Yankees rule!') instructs the interpreter to call the function12 print, which outputs the string Yankees rule! to the window associated with the shell. The sequence of commands print('Yankees rule!') print('But not in Boston!') print('Yankees rule,', 'but not in Boston!') causes the interpreter to produce the output Yankees rule! But not in Boston! Yankees rule, but not in Boston! Notice that two values were passed to print in the third statement. The print function takes a variable number of arguments separated by commas and prints them, separated by a space character, in the order in which they appear. 2.2.1 Objects, Expressions, and Numerical Types Objects are the core things that Python programs manipulate. Each object has a type that defines what programs can do with that object. Types are either scalar or non-scalar. Scalar objects are indivisible.

Dictionaries are one of the great things about Python. They greatly reduce the difficulty of writing a variety of programs. For example, in Figure 5-9 we use dictionaries to write a (pretty horrible) program to translate between languages. The code in the figure prints Je bois "good" rouge vin, et mange pain. I drink of wine red. Remember that dictionaries are mutable. So, be careful about side effects. For example, FtoE['bois'] = 'wood' print(translate('Je bois du vin rouge. ', dicts, 'French to English')) will print I wood of wine red. Figure 5-9 Translating text (badly) Many programming languages do not contain a built-in type that provides a mapping from keys to values. Instead, programmers use other types to provide similar functionality. It is, for example, relatively easy to implement a dictionary by using a list in which each element is a tuple representing a key/value pair. We can then write a simple function that does the associative retrieval, e.g., def key_search(L, k): for elem in L: if elem[0] == k: return elem[1] return None The problem with such an implementation is that it is computationally inefficient. In the worst case, a program might have to examine each element in the list to perform a single retrieval. In contrast, the built-in implementation is fast. It uses a technique called hashing, described in Chapter 12, to do the lookup in time that is nearly independent of the size of the dictionary. There are multiple ways to use a for statement to iterate over the entries in a dictionary. If d is a dictionary, a loop of the form for k in d iterates over the keys of d. The order in which the keys are chosen is the order in which the keys were inserted in the dictionary.37 For example, capitals = {'France': 'Paris', 'Italy': 'Rome', 'Japan': 'Kyoto'} for key in capitals: print('The capital of', key, 'is', capitals[key]) prints The capital of France is Paris The capital of Italy is Rome The capital of Japan is Kyoto To iterate over the values in a dictionary, we can use the method values. For example, cities = [] for val in capitals.values(): cities.append(val) print(cities, 'is a list of capital cities') prints ['Paris', 'Rome', 'Kyoto'] is a list of capital cities.